пакет ru.bgpu.task.deque;

импортируйте java.util.Arrays;

открытый класс Deque<T> реализует IDeque<T> {
	частный объект[] объекты;
	частный  размер int
	частный внутренний указатель;

	общий  размер (int
		если (размер <= 0) {
			 создать новое исключение RuntimeException("Недопустимый размер массива");
		}
		this.objects = new Object[size];
		this.size = size;
		this.backPointer = 0;
	}

	@Override
	public boolean isEmpty() {
		for (Object item : objects) {
			if (item != null) {
				return false;
			}
		}
		возвращает true;
	}

	@Переопределить
	общедоступное логическое значение является полным() {
		для (предметный элемент: объекты) {
			если (элемент == null) {
				возвращает false;
			}
		}
		возвращает true;
	}

	@Переопределить
	публичный  откат с аннулированием( значение T) {
		если ((Указатель) > (объекты.длина - 1)) {
			allocMemory();
		}
		объекты[Обратный указатель] = значение;
		backPointer++;
	}

	@Переопределить
	@Подавлениепредупреждений ("непроверено")
	публичный  откат() {
		если (обратный указатель != 0) {
			Указатель--;
			Объект tmp = объекты[Обратный указатель];
			объекты[Обратный указатель] = null;
			возврат (T) tmp;
		}
		возврат (T) объектов[0];
	}

	@Переопределить
	@Подавлениепредупреждений ("непроверено")
	публичный  просмотр() {
		если (обратный указатель != 0) {
			возврат (T) объектов[Обратный указатель - 1];
		}
		возврат (T) объектов[0];
	}

	@Переопределить
	общедоступный пустой pushFront( значение T) {
		если ((Указатель) > (объекты.длина - 1)) {
			allocMemory();
		}
		если (objects.length - 1 > = 0) {
			System.arraycopy(объекты, 0, объекты, 1, объекты.длина - 1);
		}
		объекты[0] = значение;
		backPointer++;
	}

	@Переопределить
	@Подавлениепредупреждений ("непроверено")
	публичный T popFront() {
		если (обратный указатель != 0) {
			Объект tmp = объекты[0];
			System.arraycopy(объекты, 1, объекты, 0, объекты.длина - 1);
			Указатель--;
			возврат (T) tmp;
		}
		Объект tmp = объекты[0];
		объекты[0] = null;
		возврат (T) tmp;
	}

	@Override
	@SuppressWarnings("unchecked")
	public T peekFront() {
		return (T) objects[0];
	}

	public int getDequeSize() {
		возвращать объекты.длина;
	}

	частная пустая allocMemory() {
		объекты = Массивы.copyOf(объекты, размер * 2);
		размер = объекты.длина;
	}

	public void optimizeMemorySize() {
		 общее количество = 0;
		для (предметный элемент: объекты) {
			если (элемент != null) {
				количество++;
			}
		}
		Объект[] tmp = новый объект[количество];
		для (int i = 0; i < count; i++) {
			если (объекты[i] != null) {
				tmp[i] = объекты[i];
			}
		}
		объекты = tmp;
		размер = объекты.длина;
		Указатель = объекты.длина;
	}
}